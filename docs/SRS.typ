#set page(
	paper: "a4",
	margin: (top: 2.5cm, bottom: 2.5cm, left: 2.5cm, right: 2.5cm),
	header: none,
	footer: context[
		#let actual = here().page()
		#if actual > 3 {
			stack(
				align(left)[#text(size: 9pt, style: "italic")[Blazelint - WIP]],
				align(right)[#counter(page).display("1/1", both: true)],
			)
		}
	],
)

#align(center)[
	#v(8em)
	#text(size: 36pt, weight: "bold")[Blazelint]
	#v(1.5em)
	#text(size: 24pt)[Software Requirements Specification]
	#v(2em)
	#text(size: 16pt)[Version 0.1 - draft]
	#v(4em)
	#text(size: 12pt)[Prepared by RuztyCrabs]
	#v(1em)
	#text(size: 12pt)[October 2025]
]

#pagebreak()

#outline(title: "Table of Contents")

#pagebreak()

#counter(page).update(1)

= Blazelint Software Requirements Specification

This Software Requirements Specification (SRS) captures the agreed scope, stakeholders, system expectations, and measurable requirements for the Blazelint project, following ISO/IEC/IEEE 29148:2018 guidance.

== 1 Introduction

=== 1.1 Purpose
Blazelint is a work-in-progress high performance linter for the Ballerina programming language. This document defines the functional and nonfunctional requirements that the Blazelint system shall satisfy.

=== 1.2 Intended Audience
- Core maintainers who extend the linter's internals and maintain the Rust code base.
- Contributors ramping onto the project who need a definitive description of current and planned behaviour.
- Stakeholders consuming lint results—developers.

=== 1.3 Intended Use
This SRS guides implementation, testing, and roadmap planning for Blazelint. It serves as:
- A contract of expected behaviour between maintainers and consumers.
- A baseline for evaluating change requests and enhancements.

=== 1.4 Product Scope
The scope covers the command-line application that tokenises, parses, semantically analyses, and reports diagnostics for Ballerina source files. The initial release focuses on a curated subset of Ballerina constructs already represented in the repository's lexer, parser, and semantic analyzer. Future lint rules and configuration capabilities are included as near-term enhancements so they can be planned, staffed, and validated.

=== 1.5 Definitions, Acronyms, and Abbreviations
- AST: Abstract Syntax Tree generated by the parser to represent program structure.
- CLI: Command-Line Interface used to invoke the linter from developer workstations or automation pipelines.
- Diagnostic: A structured message carrying severity, span, and optional notes reported to the end user.
- Final variable: A variable declared with the `final` keyword that must not be reassigned after initialisation.
- Span: Byte range within the original source used to map diagnostics to lines and columns.

=== 1.6 References
- Repository README (`README.md`).
- Ballerina subset grammar (`BNF.md`).
- Rust edition 2021 language specification.

=== 1.7 Document Overview
Section 2 summarises the product context. Section 3 consolidates specific requirements, covering functional capabilities, external interfaces, nonfunctional qualities, and verification expectations. Section 4 outlines project risks, and the appendix provides supporting glossary terms.

== 2 Overall Description

=== 2.1 User Needs
- Developers require rapid feedback on syntax and type issues in Ballerina source files prior to executing full builds or deployments.
- Maintainers need deterministic diagnostics with precise source spans to support automation and regression testing.
- Teams planning future lint rules need an extensible pipeline that exposes tokens, AST nodes, and semantic analysis results.

=== 2.2 Product Perspective
Blazelint operates as a standalone CLI binary built in Rust. It reads Ballerina source files from disk, emits the token stream for debugging, constructs an AST, applies semantic rules, and prints diagnostics to stdout/stderr. The tool integrates into developer workflows and continuous integration pipelines without a graphical interface. The current code base implements lexer, parser, diagnostic renderer, and semantic analyzer modules invoked by `src/main.rs`.

=== 2.3 Product Functions
- Accept a Ballerina source file path provided as a CLI argument.
- Produce a debug dump of the input file, tokens, and AST for successful analyses.
- Surface lexer, parser, or semantic diagnostics with byte-accurate highlights.
- Enforce type rules for primitive declarations, assignments, control flow, and function returns.
- Exit with a non-zero status whenever diagnostics are present.
- Prepare the code base for future lint rule execution, configuration, and richer reporting.

=== 2.4 User Classes and Characteristics
- Core maintainers: Rust developers extending the linter internals, comfortable with compiler architecture and typst documentation.
- Power users: Ballerina developers who run the CLI locally to validate code style and type constraints.
- Automation systems: Continuous integration jobs or pre-commit hooks that invoke the binary headlessly.

=== 2.5 Operating Environment
- Target platforms: Linux, macOS, and Windows environments or newer (optionally Rust toolchain 1.70 or later is required if building form source).
- Execution context: Terminal sessions or scripted CI environments capable of executing native binaries and accessing the filesystem.
- Input artifacts: Text files encoded in UTF-8 following the Ballerina grammar subset defined in `BNF.md`.

=== 2.6 Design and Implementation Constraints
- Implemented exclusively in Rust 2021 edition; no runtime dependencies beyond the standard library.
- Grammar limited to the subset explicitly documented; unrecognised constructs must be rejected with diagnostics.
- Offline operation: the tool may not rely on network connectivity at runtime.
- Diagnostic formatting must align with current integration tests to preserve compatibility.

=== 2.7 User Documentation
Primary references include the project README and BNF grammar document. Additional documentation must be co-located in the repository and versioned with code changes.

=== 2.8 Assumptions and Dependencies
- Users possess access rights to read the source files provided to the CLI.
- Input files are syntactically plain text with Unix or Windows line endings.
- Future lint rule execution will build on the existing AST and semantic outputs without altering upstream parser behaviour.
- Integration with IDEs or editors, if pursued later, will consume the CLI output or LSP protocol rather than embedding the linter directly.

== 3 Specific Requirements

This section records functional behaviour, interface expectations, quality attributes, and verification practices. Functional requirement identifiers follow the pattern FR-XX for present capabilities and FR-FUT-XX for future roadmap items.

=== 3.1 Functional Requirements

==== 3.1.1 Command-Line Invocation
The CLI entry point coordinates reading the source file, executing the pipeline, and reporting results.
- FR-01: The application shall require at least one positional CLI argument representing the path to a source file; missing arguments must trigger a usage message and exit code 1.
- FR-02: The application shall read the specified file as UTF-8 text and terminate with an explanatory diagnostic when the file cannot be accessed.
- FR-03: When the analysis pipeline completes without diagnostics, the system shall print the raw input, the lexed token stream, and the formatted AST to stdout.
- FR-04: The application shall terminate with a non-zero exit code whenever lexer, parser, or semantic diagnostics are produced.
- FR-FUT-01: The CLI shall accept additional arguments to control linting scope (file or directory), configuration file path, and output format once lint rules are introduced (per README remaining tasks).

==== 3.1.2 Lexical Analysis
The lexer converts raw input into labelled tokens while detecting malformed constructs.
- FR-05: The lexer shall emit tokens covering keywords (`final`, `var`, `function`, `if`, `else`, `return`, `panic`), primitive types, identifiers, literals, delimiters, and operators defined in `BNF.md`.
- FR-06: The lexer shall produce diagnostics with spans for unterminated strings, unterminated block comments, unexpected characters, malformed number literals, and disallowed single ampersand usage (validated by `tests/cli_diagnostics.rs`).
- FR-07: The lexer shall preserve start and end byte offsets for every token to enable column-accurate diagnostics and AST annotations.
- FR-FUT-02: The lexer shall be extensible to recognise additional Ballerina constructs (loops, structured types) without breaking existing token contracts.

==== 3.1.3 Parsing and AST Construction
The parser builds structured syntax trees and enforces syntactic rules.
- FR-08: The parser shall transform the token list into AST statements supporting variable declarations, function declarations, `if` statements, return statements, panic statements, and expressions with operator precedence.
- FR-09: The parser shall produce parser diagnostics with expectation notes for missing delimiters, invalid assignment targets, and unexpected end-of-file events.
- FR-10: The parser shall preserve spans for identifiers, expressions, and statements to power downstream semantic checks.
- FR-FUT-03: The parser shall expand to additional syntax categories (loops, structured types) coordinated with the grammar backlog.

==== 3.1.4 Semantic Analysis
The semantic analyzer validates type rules, scope, and finality.
- FR-11: The analyzer shall infer or confirm variable types, ensuring explicit annotations match initializer types and `var` declarations adopt the initializer's type.
- FR-12: The analyzer shall enforce assignment rules, detecting reassignment to `final` variables and type mismatches, and report diagnostics referencing the offending span.
- FR-13: The analyzer shall validate control flow constructs by requiring boolean `if` conditions and ensuring function returns honour declared return types.
- FR-14: The analyzer shall treat unknown identifiers as errors while allowing placeholders for yet-unbound function names captured in the roadmap.
- FR-FUT-04: The analyzer shall evolve to support built-in lint rules that operate on the annotated AST (naming, style, configuration-driven severities).

==== 3.1.5 Diagnostic Reporting
The diagnostic renderer translates internal diagnostic objects into human-readable output.
- FR-15: The renderer shall map byte spans to 1-based line and column pairs and display the associated source line with caret highlights.
- FR-16: The renderer shall print the diagnostic kind prefix (lexer, parser, semantic) followed by the message and any supplemental notes.
- FR-17: The renderer shall support multiple diagnostics per run, formatting each sequentially and preserving the original ordering from the pipeline.
- FR-FUT-05: The renderer shall offer alternative output formats (JSON, compact text) to integrate with IDEs and CI dashboards.

==== 3.1.6 Lint Rule Framework (Roadmap)
Future iterations will add linting capabilities beyond strict syntax and type validation.
- FR-FUT-06: The system shall allow users to enable, disable, or configure lint rules via a `.blazerc` configuration file.
- FR-FUT-07: The system shall ship with a baseline set of naming and best-practice rules leveraging semantic information.
- FR-FUT-08: The CLI shall provide summary reporting of lint findings, including counts, severities, and exit codes aligned with configured policies.

=== 3.2 Non-Functional Requirements

==== 3.2.1 Performance
- NFR-01: The linter shall process single-file inputs under 2,000 lines within 1 second on a mid-range developer laptop (Intel i5/Ryzen 5 class) when no diagnostics are emitted.
- NFR-02: Diagnostic generation shall add no more than 20 percent overhead relative to a clean run for the same input.

==== 3.2.2 Reliability
- NFR-03: The tool shall exit gracefully with informative diagnostics when encountering malformed input instead of panicking.
- NFR-04: Unit and integration tests shall cover representative lexer, parser, and semantic failure modes with deterministic outcomes.

==== 3.2.3 Usability
- NFR-05: Command-line feedback shall include explicit success confirmation (e.g., "Lexing complete!" and AST snapshot) for passing runs to aid debugging.
- NFR-06: Error messages shall include actionable notes where available (expected tokens, type names).

==== 3.2.4 Security
- NFR-07: The tool shall not execute user-provided code or external commands during analysis (ex: code injection).
- NFR-08: The tool shall avoid writing to the input directory except for diagnostics printed to stdout/stderr.

==== 3.2.5 Maintainability
- NFR-09: The code base shall remain rustfmt and clippy clean for the optimal code quality, enforced via `scripts/check.sh` prior to pull requests.
- NFR-10: New features shall include documentation updates in the `docs/` or `README.md` directories.

==== 3.2.6 Portability
- NFR-11: The binary shall build and run on stable Rust toolchains for Linux, macOS, and Windows without platform-specific feature flags.
- NFR-12: Typst documentation artifacts, including this SRS, shall render consistently across environments.

==== 3.2.7 Supportability
- NFR-13: The repository shall include onboarding documentation describing the pipeline architecture and semantic plan, enabling new contributors to ramp up within one week.

=== 3.3 External Interface Requirements

==== 3.3.1 Performance Requirements
- CLI executions shall complete without exceeding system memory beyond the size of the source file and associated token/AST representations.
- Integration in CI must support concurrent executions on shared runners without cross-interference (stateless operation).

==== 3.3.2 Safety Requirements
- The linter shall operate in read-only mode on supplied files; it shall not modify source artifacts or dependent resources.
- The linter shall fail closed, emitting diagnostics instead of proceeding when encountering parsing or semantic errors.

==== 3.3.3 Security Requirements
- File access is limited to user-provided paths; no external network communication is permitted.
- Error output shall avoid leaking sensitive filesystem metadata beyond provided paths.

==== 3.3.4 Software Quality Attributes
- Maintain consistent diagnostic formatting to preserve compatibility with downstream tooling that may parse the output.
- Provide deterministic results for identical inputs to support reproducible builds.

==== 3.3.5 Business Rules
- Exit status codes must align with automation expectations: zero for success, non-zero for any diagnostics.
- Future lint rule severities shall map to business-defined policies (warning vs. error) configurable via `.blazerc`.

=== 3.4 System Features
- Lexical analysis producing token streams with spans.
- Parsing into AST structures representing supported Ballerina constructs.
- Semantic analysis enforcing type and scope rules.
- Diagnostic rendering with source highlights and notes.
- Roadmap lint framework enabling configurable rule execution.

=== 3.5 Verification and Validation

- VV-01: Maintain integration tests in `tests/cli_diagnostics.rs` that assert CLI exit codes and diagnostic messages for representative success and failure cases.
- VV-02: Add snapshot or golden tests for AST output to guard parser regressions (tracked in `progress.md`).
- VV-03: Introduce unit tests for semantic analyzer functions covering type mismatch, final enforcement, and control flow validation.
- VV-04: Validate future lint rules with targeted fixtures ensuring configuration options affect severities and exit codes as expected.

== 4 Other Requirements

=== 4.1 Database Requirements
No persistent database is required. The tool operates on in-memory representations of the provided source file and writes no state to disk beyond optional diagnostic output. Should future features introduce caching, they must store artefacts in user-configurable locations and respect security requirements in §3.2.4.

=== 4.2 Legal and Regulatory Requirements
- Comply with the Ballerina language licensing terms when distributing grammars or sample code in documentation or tests.
- Ensure all third-party Rust crates used (e.g., `assert_cmd`, `tempfile`) retain compatible open-source licenses; document attributions in `Cargo.toml` or `README.md` if required.

=== 4.3 Internationalization and Localization
- Diagnostics shall remain in English for the MVP. Future localisation efforts must preserve span accuracy and avoid breaking automated parsing of output.
- Accept UTF-8 input sources, ensuring multi-byte characters are counted accurately when computing spans and caret highlights.

=== 4.4 Risk Management (FMEA Overview)
| Risk ID | Failure Mode | Effect | Mitigation |
| --- | --- | --- | --- |
| R-01 | Grammar expansion introduces ambiguity | Parser rejects valid programs | Add parser unit tests and AST snapshots before expanding grammar; stage changes behind feature flags |
| R-02 | Semantic rule growth impacts performance | Slower lint runs degrade developer experience | Profile semantic pass, cache scope lookups, and maintain performance benchmarks | 
| R-03 | Missing lint configuration | Users cannot tailor severity to workflows | Design `.blazerc` early, define default policies, and document override behaviour |

== 5 Appendices

=== 5.1 Glossary
- Analyzer: Component responsible for semantic validation.
- Ballerina subset: The limited set of language features currently recognised by Blazelint.
- Diagnostic note: Supplemental textual hint attached to a diagnostic to guide remediation.
- Roadmap feature: Requirement marked with FR-FUT or NFR-FUT identifiers scheduled for future iterations.

=== 5.2 Use Cases and Diagrams
- #strong[UC-01: Lint Single File via CLI] – Developer invokes `blazelint test.bal`, receives diagnostics or AST output.
- #strong[UC-02: CI Validation] – Automation job runs the binary on repository sources, fails the pipeline when non-zero exit status is returned.
- #strong[UC-03: Extend Semantic Rules] – Maintainer author new semantic checks referencing this SRS for acceptance criteria and updates integration tests.
Future visual diagrams may be generated from Typst or Mermaid blocks and linked here when available.

=== 5.3 To Be Determined (TBD) List
- TBD-01: Specific `.blazerc` configuration schema (keys, severity mapping format).
- TBD-02: Lint rule catalogue and naming conventions for the MVP.
- TBD-03: Additional output formats (JSON schema) for diagnostics.
